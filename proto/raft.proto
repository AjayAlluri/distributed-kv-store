syntax = "proto3";

package raft;

option go_package = "github.com/ajayalluri/distributed-kv-store/proto";

// Raft service for inter-node communication
service RaftService {
  // RequestVote RPC for leader election
  rpc RequestVote(VoteRequest) returns (VoteResponse);
  
  // AppendEntries RPC for log replication and heartbeats
  rpc AppendEntries(AppendEntriesRequest) returns (AppendEntriesResponse);
  
  // InstallSnapshot RPC for snapshot transfers
  rpc InstallSnapshot(InstallSnapshotRequest) returns (InstallSnapshotResponse);
}

// VoteRequest message for leader election
message VoteRequest {
  uint64 term = 1;           // Candidate's term
  string candidate_id = 2;   // Candidate requesting vote
  uint64 last_log_index = 3; // Index of candidate's last log entry
  uint64 last_log_term = 4;  // Term of candidate's last log entry
}

// VoteResponse message for leader election
message VoteResponse {
  uint64 term = 1;         // Current term, for candidate to update itself
  bool vote_granted = 2;   // True means candidate received vote
}

// AppendEntriesRequest message for log replication
message AppendEntriesRequest {
  uint64 term = 1;          // Leader's term
  string leader_id = 2;     // So follower can redirect clients
  uint64 prev_log_index = 3; // Index of log entry immediately preceding new ones
  uint64 prev_log_term = 4;  // Term of prevLogIndex entry
  repeated LogEntry entries = 5; // Log entries to store (empty for heartbeat)
  uint64 leader_commit = 6;  // Leader's commitIndex
}

// AppendEntriesResponse message for log replication
message AppendEntriesResponse {
  uint64 term = 1;    // Current term, for leader to update itself
  bool success = 2;   // True if follower contained entry matching prevLogIndex and prevLogTerm
  
  // Optimization fields for faster log replication
  uint64 conflict_term = 3;  // Term of conflicting entry
  uint64 conflict_index = 4; // First index with conflict_term
}

// LogEntry represents a single entry in the Raft log
message LogEntry {
  uint64 term = 1;    // Term when entry was received by leader
  uint64 index = 2;   // Position in the log
  bytes data = 3;     // Serialized command data
}

// Snapshot represents a point-in-time state machine snapshot
message Snapshot {
  uint64 last_included_index = 1; // The snapshot replaces all entries up through this index
  uint64 last_included_term = 2;  // Term of last_included_index
  bytes state_machine_data = 3;   // Serialized state machine data
  repeated string membership = 4;  // Current cluster membership
  int64 timestamp = 5;            // Unix timestamp when snapshot was created
  uint64 checksum = 6;            // CRC32 checksum for integrity verification
}

// InstallSnapshotRequest message for snapshot transfers
message InstallSnapshotRequest {
  uint64 term = 1;               // Leader's term
  string leader_id = 2;          // So follower can redirect clients
  uint64 last_included_index = 3; // The snapshot replaces all entries up through this index
  uint64 last_included_term = 4;  // Term of last_included_index
  uint64 offset = 5;             // Byte offset where chunk is positioned in snapshot file
  bytes data = 6;                // Raw bytes of snapshot chunk
  bool done = 7;                 // True if this is the last chunk
  uint64 total_size = 8;         // Total size of the complete snapshot
  uint64 checksum = 9;           // Checksum of complete snapshot for verification
}

// InstallSnapshotResponse message for snapshot transfers
message InstallSnapshotResponse {
  uint64 term = 1;    // Current term, for leader to update itself
  bool success = 2;   // True if snapshot chunk was successfully received
  uint64 bytes_received = 3; // Number of bytes successfully received so far
}